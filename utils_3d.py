"""
3D utility functions for creating textured meshes.
"""

import numpy as np
import trimesh
from PIL import Image
import os
from typing import Tuple, List

def create_cube_mesh(size: float = 1.0) -> trimesh.Trimesh:
    """
    Create a simple cube mesh.
    
    Args:
        size (float): Size of the cube
        
    Returns:
        trimesh.Trimesh: Cube mesh
    """
    # Create cube vertices
    vertices = np.array([
        # Front face
        [-size/2, -size/2,  size/2],  # 0
        [ size/2, -size/2,  size/2],  # 1
        [ size/2,  size/2,  size/2],  # 2
        [-size/2,  size/2,  size/2],  # 3
        # Back face
        [-size/2, -size/2, -size/2],  # 4
        [ size/2, -size/2, -size/2],  # 5
        [ size/2,  size/2, -size/2],  # 6
        [-size/2,  size/2, -size/2],  # 7
    ])
    
    # Define faces (triangles)
    faces = np.array([
        # Front face
        [0, 1, 2], [0, 2, 3],
        # Back face
        [5, 4, 7], [5, 7, 6],
        # Right face
        [1, 5, 6], [1, 6, 2],
        # Left face
        [4, 0, 3], [4, 3, 7],
        # Top face
        [3, 2, 6], [3, 6, 7],
        # Bottom face
        [4, 5, 1], [4, 1, 0]
    ])
    
    # Create mesh
    mesh = trimesh.Trimesh(vertices=vertices, faces=faces)
    return mesh

def create_textured_cube(texture_image: Image.Image, output_path: str = None) -> str:
    """
    Create a textured cube mesh from a texture image.
    
    Args:
        texture_image (PIL.Image.Image): Texture image to apply
        output_path (str): Output path for the .obj file
        
    Returns:
        str: Path to the saved .obj file
    """
    # Generate output path if not provided
    if output_path is None:
        import hashlib
        import datetime
        from config import DEFAULT_OUTPUT_CONFIG
        texture_hash = hashlib.md5(texture_image.tobytes()).hexdigest()[:8]
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"textured_cube_{texture_hash}_{timestamp}.obj"
        output_path = os.path.join(DEFAULT_OUTPUT_CONFIG.output_dir, filename)
    
    # Ensure output directory exists
    output_dir = os.path.dirname(output_path) if os.path.dirname(output_path) else "."
    os.makedirs(output_dir, exist_ok=True)
    
    # Create OBJ file with proper UV mapping
    obj_content = f"""# Textured Cube OBJ File
# Generated by MeshMorph AI

mtllib {os.path.basename(output_path).replace('.obj', '.mtl')}

# Vertices
v -0.5 -0.5  0.5
v  0.5 -0.5  0.5
v  0.5  0.5  0.5
v -0.5  0.5  0.5
v -0.5 -0.5 -0.5
v  0.5 -0.5 -0.5
v  0.5  0.5 -0.5
v -0.5  0.5 -0.5

# Texture coordinates (UV)
vt 0.0 0.0
vt 1.0 0.0
vt 1.0 1.0
vt 0.0 1.0

# Normals
vn  0.0  0.0  1.0
vn  0.0  0.0 -1.0
vn  1.0  0.0  0.0
vn -1.0  0.0  0.0
vn  0.0  1.0  0.0
vn  0.0 -1.0  0.0

# Material
usemtl material0

# Faces with texture coordinates and normals
# Front face
f 1/1/1 2/2/1 3/3/1 4/4/1
# Back face
f 6/1/2 5/2/2 8/3/2 7/4/2
# Right face
f 2/1/3 6/2/3 7/3/3 3/4/3
# Left face
f 5/1/4 1/2/4 4/3/4 8/4/4
# Top face
f 4/1/5 3/2/5 7/3/5 8/4/5
# Bottom face
f 5/1/6 6/2/6 2/3/6 1/4/6
"""
    
    with open(output_path, 'w') as f:
        f.write(obj_content)
    
    # Create a material file (.mtl) for the texture
    mtl_path = output_path.replace('.obj', '.mtl')
    mtl_content = f"""# Material file for textured cube
# Generated by MeshMorph AI

newmtl material0
Ns 32
Ka 1.000000 1.000000 1.000000
Kd 1.000000 1.000000 1.000000
Ks 0.500000 0.500000 0.500000
Ni 1.000000
d 1.000000
illum 2
map_Kd {os.path.basename(output_path).replace('.obj', '.png')}
"""
    
    with open(mtl_path, 'w') as f:
        f.write(mtl_content)
    
    # Save the texture image alongside the OBJ file
    texture_path = output_path.replace('.obj', '.png')
    texture_image.save(texture_path)
    
    return output_path

def create_textured_sphere(texture_image: Image.Image, output_path: str = None, radius: float = 1.0) -> str:
    """
    Create a textured sphere mesh from a texture image.
    
    Args:
        texture_image (PIL.Image.Image): Texture image to apply
        output_path (str): Output path for the .obj file
        radius (float): Radius of the sphere
        
    Returns:
        str: Path to the saved .obj file
    """
    # Generate output path if not provided
    if output_path is None:
        import hashlib
        import datetime
        from config import DEFAULT_OUTPUT_CONFIG
        texture_hash = hashlib.md5(texture_image.tobytes()).hexdigest()[:8]
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"textured_sphere_{texture_hash}_{timestamp}.obj"
        output_path = os.path.join(DEFAULT_OUTPUT_CONFIG.output_dir, filename)
    
    # Ensure output directory exists
    output_dir = os.path.dirname(output_path) if os.path.dirname(output_path) else "."
    os.makedirs(output_dir, exist_ok=True)
    
    # Create a simple sphere with UV mapping
    # This is a simplified sphere with 8 segments
    segments = 8
    rings = 6
    
    obj_content = f"""# Textured Sphere OBJ File
# Generated by MeshMorph AI

mtllib {os.path.basename(output_path).replace('.obj', '.mtl')}

# Vertices
"""
    
    # Generate vertices
    for ring in range(rings + 1):
        phi = (ring / rings) * np.pi
        y = radius * np.cos(phi)
        r = radius * np.sin(phi)
        
        for segment in range(segments + 1):
            theta = (segment / segments) * 2 * np.pi
            x = r * np.cos(theta)
            z = r * np.sin(theta)
            obj_content += f"v {x:.6f} {y:.6f} {z:.6f}\n"
    
    # Generate texture coordinates
    obj_content += "\n# Texture coordinates\n"
    for ring in range(rings + 1):
        v = ring / rings
        for segment in range(segments + 1):
            u = segment / segments
            obj_content += f"vt {u:.6f} {v:.6f}\n"
    
    # Generate normals
    obj_content += "\n# Normals\n"
    for ring in range(rings + 1):
        phi = (ring / rings) * np.pi
        for segment in range(segments + 1):
            theta = (segment / segments) * 2 * np.pi
            nx = np.sin(phi) * np.cos(theta)
            ny = np.cos(phi)
            nz = np.sin(phi) * np.sin(theta)
            obj_content += f"vn {nx:.6f} {ny:.6f} {nz:.6f}\n"
    
    # Generate faces
    obj_content += "\n# Material\nusemtl material0\n\n# Faces\n"
    for ring in range(rings):
        for segment in range(segments):
            # Calculate vertex indices
            v1 = ring * (segments + 1) + segment + 1
            v2 = ring * (segments + 1) + segment + 2
            v3 = (ring + 1) * (segments + 1) + segment + 2
            v4 = (ring + 1) * (segments + 1) + segment + 1
            
            # Calculate texture and normal indices (same as vertex indices)
            vt1, vt2, vt3, vt4 = v1, v2, v3, v4
            vn1, vn2, vn3, vn4 = v1, v2, v3, v4
            
            obj_content += f"f {v1}/{vt1}/{vn1} {v2}/{vt2}/{vn2} {v3}/{vt3}/{vn3} {v4}/{vt4}/{vn4}\n"
    
    with open(output_path, 'w') as f:
        f.write(obj_content)
    
    # Create a material file (.mtl) for the texture
    mtl_path = output_path.replace('.obj', '.mtl')
    mtl_content = f"""# Material file for textured sphere
# Generated by MeshMorph AI

newmtl material0
Ns 32
Ka 1.000000 1.000000 1.000000
Kd 1.000000 1.000000 1.000000
Ks 0.500000 0.500000 0.500000
Ni 1.000000
d 1.000000
illum 2
map_Kd {os.path.basename(output_path).replace('.obj', '.png')}
"""
    
    with open(mtl_path, 'w') as f:
        f.write(mtl_content)
    
    # Save the texture image alongside the OBJ file
    texture_path = output_path.replace('.obj', '.png')
    texture_image.save(texture_path)
    
    return output_path

def create_textured_cylinder(texture_image: Image.Image, output_path: str = None, 
                           radius: float = 0.5, height: float = 2.0) -> str:
    """
    Create a textured cylinder mesh from a texture image.
    
    Args:
        texture_image (PIL.Image.Image): Texture image to apply
        output_path (str): Output path for the .obj file
        radius (float): Radius of the cylinder
        height (float): Height of the cylinder
        
    Returns:
        str: Path to the saved .obj file
    """
    # Generate output path if not provided
    if output_path is None:
        import hashlib
        import datetime
        from config import DEFAULT_OUTPUT_CONFIG
        texture_hash = hashlib.md5(texture_image.tobytes()).hexdigest()[:8]
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"textured_cylinder_{texture_hash}_{timestamp}.obj"
        output_path = os.path.join(DEFAULT_OUTPUT_CONFIG.output_dir, filename)
    
    # Ensure output directory exists
    output_dir = os.path.dirname(output_path) if os.path.dirname(output_path) else "."
    os.makedirs(output_dir, exist_ok=True)
    
    # Create a cylinder with UV mapping
    segments = 12
    rings = 4
    
    obj_content = f"""# Textured Cylinder OBJ File
# Generated by MeshMorph AI

mtllib {os.path.basename(output_path).replace('.obj', '.mtl')}

# Vertices
"""
    
    # Generate vertices for the cylinder body
    for ring in range(rings + 1):
        y = (ring / rings - 0.5) * height
        for segment in range(segments + 1):
            theta = (segment / segments) * 2 * np.pi
            x = radius * np.cos(theta)
            z = radius * np.sin(theta)
            obj_content += f"v {x:.6f} {y:.6f} {z:.6f}\n"
    
    # Generate texture coordinates
    obj_content += "\n# Texture coordinates\n"
    for ring in range(rings + 1):
        v = ring / rings
        for segment in range(segments + 1):
            u = segment / segments
            obj_content += f"vt {u:.6f} {v:.6f}\n"
    
    # Generate normals
    obj_content += "\n# Normals\n"
    for ring in range(rings + 1):
        for segment in range(segments + 1):
            theta = (segment / segments) * 2 * np.pi
            nx = np.cos(theta)
            ny = 0.0
            nz = np.sin(theta)
            obj_content += f"vn {nx:.6f} {ny:.6f} {nz:.6f}\n"
    
    # Generate faces for the cylinder body
    obj_content += "\n# Material\nusemtl material0\n\n# Faces\n"
    for ring in range(rings):
        for segment in range(segments):
            # Calculate vertex indices
            v1 = ring * (segments + 1) + segment + 1
            v2 = ring * (segments + 1) + segment + 2
            v3 = (ring + 1) * (segments + 1) + segment + 2
            v4 = (ring + 1) * (segments + 1) + segment + 1
            
            # Calculate texture and normal indices (same as vertex indices)
            vt1, vt2, vt3, vt4 = v1, v2, v3, v4
            vn1, vn2, vn3, vn4 = v1, v2, v3, v4
            
            obj_content += f"f {v1}/{vt1}/{vn1} {v2}/{vt2}/{vn2} {v3}/{vt3}/{vn3} {v4}/{vt4}/{vn4}\n"
    
    with open(output_path, 'w') as f:
        f.write(obj_content)
    
    # Create a material file (.mtl) for the texture
    mtl_path = output_path.replace('.obj', '.mtl')
    mtl_content = f"""# Material file for textured cylinder
# Generated by MeshMorph AI

newmtl material0
Ns 32
Ka 1.000000 1.000000 1.000000
Kd 1.000000 1.000000 1.000000
Ks 0.500000 0.500000 0.500000
Ni 1.000000
d 1.000000
illum 2
map_Kd {os.path.basename(output_path).replace('.obj', '.png')}
"""
    
    with open(mtl_path, 'w') as f:
        f.write(mtl_content)
    
    # Save the texture image alongside the OBJ file
    texture_path = output_path.replace('.obj', '.png')
    texture_image.save(texture_path)
    
    return output_path 